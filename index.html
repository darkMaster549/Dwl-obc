<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Roblox Script Obfuscator</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
            margin: 0;
            padding: 20px;
        }
        
        .container {
            max-width: 800px;
            margin: 0 auto;
            background-color: white;
            border: 2px solid #ccc;
            padding: 20px;
        }
        
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 20px;
        }
        
        .input-section {
            margin-bottom: 20px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #555;
        }
        
        textarea {
            width: 100%;
            height: 300px;
            padding: 10px;
            border: 2px solid #ddd;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            resize: vertical;
            box-sizing: border-box;
        }
        
        .button-section {
            text-align: center;
            margin: 20px 0;
        }
        
        button {
            background-color: #4CAF50;
            color: white;
            padding: 15px 30px;
            font-size: 16px;
            border: none;
            cursor: pointer;
            border-radius: 4px;
        }
        
        button:hover {
            background-color: #45a049;
        }
        
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        
        .status {
            text-align: center;
            margin: 10px 0;
            font-weight: bold;
        }
        
        .success {
            color: #4CAF50;
        }
        
        .error {
            color: #f44336;
        }
        
        .footer {
            text-align: center;
            margin-top: 20px;
            color: #666;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Roblox Script Obfuscator</h1>
        <p style="text-align: center; color: #666;">Put Your Whole Roblox Script for your Delta, KRNL, executors</p>
        
        <div class="input-section">
            <label for="scriptInput">Enter your Roblox script:</label>
            <textarea id="scriptInput" placeholder="-- Put your Roblox Lua script here
print('Hello World!')
game:GetService('Players').LocalPlayer.Character.Humanoid.WalkSpeed = 50"></textarea>
        </div>
        
        <div class="button-section">
            <button id="obfuscateBtn" onclick="obfuscateScript()">Obfuscate Script</button>
        </div>
        
        <div id="status" class="status"></div>
        
        <div class="footer">
            <p>This tool obfuscates Roblox Lua scripts using Caesar cipher encoding</p>
            <p>The obfuscated file will be automatically downloaded</p>
        </div>
    </div>

    <script>
        function generateRandomName(len = null) {
            len = len || Math.floor(Math.random() * 5) + 8;
            const charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
            let name = "";
            for (let i = 0; i < len; i++) {
                const index = Math.floor(Math.random() * charset.length);
                name += charset[index];
            }
            return name;
        }

        function isValidChar(byte) {
            return (byte >= 48 && byte <= 57) || (byte >= 65 && byte <= 90) || (byte >= 97 && byte <= 122);
        }

        function caesarCipher(data, offset) {
            let result = "";
            for (let i = 0; i < data.length; i++) {
                const byte = data.charCodeAt(i);
                if (isValidChar(byte)) {
                    let newByte;
                    if (byte >= 48 && byte <= 57) {
                        newByte = ((byte - 48 + offset) % 10) + 48;
                    } else if (byte >= 65 && byte <= 90) {
                        newByte = ((byte - 65 + offset) % 26) + 65;
                    } else if (byte >= 97 && byte <= 122) {
                        newByte = ((byte - 97 + offset) % 26) + 97;
                    }
                    result += String.fromCharCode(newByte);
                } else {
                    result += String.fromCharCode(byte);
                }
            }
            return result;
        }

        // Variable Renamer functions
        const varencNames = {};
        const luaFunctions = [
            "assert", "collectgarbage", "dofile", "loadfile", "loadstring",
            "ipairs", "pairs", "tonumber", "tostring", "type", "print",
            "_G", "_VERSION", "write", "sort",
            "math.abs", "math.acos", "math.asin", "math.atan", "math.atan2",
            "math.ceil", "math.cos", "math.cosh", "math.deg", "math.exp",
            "math.floor", "math.fmod", "math.frexp", "math.ldexp", "math.log",
            "math.log10", "math.max", "math.min", "math.modf", "math.pi",
            "math.pow", "math.rad", "math.random", "math.randomseed", "math.sin",
            "math.sinh", "math.sqrt", "math.tan", "math.tanh",
            "string.byte", "string.char", "string.dump", "string.find",
            "string.format", "string.gmatch", "string.gsub", "string.len",
            "string.lower", "string.match", "string.rep", "string.reverse",
            "string.sub", "string.upper",
            "table.concat", "table.insert", "table.remove", "table.sort",
            "table.pack", "table.unpack"
        ];

        const reservedWords = {
            "if": true, "then": true, "else": true, "elseif": true, "end": true,
            "for": true, "while": true, "do": true, "repeat": true, "until": true,
            "function": true, "local": true, "return": true, "break": true, "continue": true,
            "and": true, "or": true, "not": true, "in": true, "nil": true,
            "true": true, "false": true
        };

        function replaceUnquoted(input, target, replacement) {
            const placeholder = "!!!";
            let protectedInput = input.replace(/(['"])((?:\\.|(?!\1)[^\\])*)\1/g, function(match, quote, content) {
                content = content.replace(/\\"/g, '!@!').replace(/\\'/g, '@!@');
                content = content.replace(new RegExp(target, 'g'), placeholder);
                content = content.replace(/!@!/g, '\\"').replace(/@!@/g, "\\'");
                return quote + content + quote;
            });
            
            const regex = new RegExp('(\\b)' + target.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '(\\b)', 'g');
            let result = protectedInput.replace(regex, '$1' + replacement + '$2');
            result = result.replace(new RegExp(placeholder, 'g'), target);
            return result;
        }

        function obfuscateLocalVariables(code) {
            const localVarPattern = /local\s+([a-zA-Z_][a-zA-Z0-9_,\s]*)\s*=/g;
            const varMap = {};
            let obfuscatedCode = code;
            let match;

            while ((match = localVarPattern.exec(code)) !== null) {
                const localVars = match[1];
                const vars = localVars.match(/[a-zA-Z_][a-zA-Z0-9_]*/g);
                if (vars) {
                    for (const varName of vars) {
                        if (varName.length > 1 && !varencNames[varName] && !reservedWords[varName]) {
                            varMap[varName] = generateRandomName();
                        }
                    }
                }
            }

            for (const [originalVar, obfuscatedVar] of Object.entries(varMap)) {
                obfuscatedCode = replaceUnquoted(obfuscatedCode, originalVar, obfuscatedVar);
            }

            return { obfuscatedCode, varMap };
        }

        function obfuscateFunctions(code) {
            const funcMap = {};
            const argMap = {};
            let obfuscatedCode = code;

            // Match function definitions
            const funcPattern = /function\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*\(([a-zA-Z0-9_,\s]*)\)/g;
            let match;

            while ((match = funcPattern.exec(code)) !== null) {
                const funcName = match[1];
                const args = match[2];

                if (!reservedWords[funcName] && !funcMap[funcName]) {
                    funcMap[funcName] = generateRandomName();
                }

                if (args) {
                    const argList = args.match(/[a-zA-Z_][a-zA-Z0-9_]*/g);
                    if (argList) {
                        for (const arg of argList) {
                            if (!reservedWords[arg] && !argMap[arg]) {
                                argMap[arg] = generateRandomName();
                            }
                        }
                    }
                }
            }

            // Replace function names
            obfuscatedCode = obfuscatedCode.replace(/function\s+([a-zA-Z_][a-zA-Z0-9_]*)/g, function(match, funcName) {
                return "function " + (funcMap[funcName] || funcName);
            });

            // Replace function calls
            for (const [originalFunc, obfuscatedFunc] of Object.entries(funcMap)) {
                const regex = new RegExp(originalFunc.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '\\(', 'g');
                obfuscatedCode = obfuscatedCode.replace(regex, obfuscatedFunc + "(");
            }

            // Replace arguments
            for (const [originalArg, obfuscatedArg] of Object.entries(argMap)) {
                obfuscatedCode = replaceUnquoted(obfuscatedCode, originalArg, obfuscatedArg);
            }

            return obfuscatedCode;
        }

        function processVariableRenaming(code) {
            const renamedVars = [];
            const assignmentLines = [];
            
            const { obfuscatedCode: varObfuscatedCode } = obfuscateLocalVariables(code);
            let finalCode = obfuscateFunctions(varObfuscatedCode);

            // Handle built-in functions
            for (const functionName of luaFunctions) {
                if (code.includes(functionName)) {
                    if (!varencNames[functionName]) {
                        const newName = generateRandomName();
                        varencNames[functionName] = newName;
                        renamedVars.push(newName);
                        assignmentLines.push(newName + " = " + functionName + ";");
                    }
                    const regex = new RegExp(functionName.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '\\(', 'g');
                    finalCode = finalCode.replace(regex, varencNames[functionName] + "(");
                }
            }

            const localDeclaration = renamedVars.length > 0 ? "local " + renamedVars.join(", ") : "";
            const assignments = assignmentLines.length > 0 ? " " + assignmentLines.join(" ") : "";
            
            return localDeclaration + assignments + " " + finalCode;
        }

        function processScript(code) {
            const randomDecryptName = generateRandomName();
            const randomIsValidCharName = generateRandomName();
            const randomResultName = generateRandomName();
            const randomCodeName = generateRandomName();
            const randomOffsetName = generateRandomName();
            const randomByteName = generateRandomName();
            const randomNewByteName = generateRandomName();

            const decodeFunction = `local function ${randomIsValidCharName}(${randomByteName}) return (${randomByteName} >= 48 and ${randomByteName} <= 57) or (${randomByteName} >= 65 and ${randomByteName} <= 90) or (${randomByteName} >= 97 and ${randomByteName} <= 122) end local function ${randomDecryptName}(${randomCodeName}, ${randomOffsetName}) local ${randomResultName} = {} for i = 1, #${randomCodeName} do local ${randomByteName} = ${randomCodeName}:byte(i) if ${randomIsValidCharName}(${randomByteName}) then local ${randomNewByteName} if ${randomByteName} >= 48 and ${randomByteName} <= 57 then ${randomNewByteName} = ((${randomByteName} - 48 - ${randomOffsetName} + 10) % 10) + 48 elseif ${randomByteName} >= 65 and ${randomByteName} <= 90 then ${randomNewByteName} = ((${randomByteName} - 65 - ${randomOffsetName} + 26) % 26) + 65 elseif ${randomByteName} >= 97 and ${randomByteName} <= 122 then ${randomNewByteName} = ((${randomByteName} - 97 - ${randomOffsetName} + 26) % 26) + 97 end table.insert(${randomResultName}, string.char(${randomNewByteName})) else table.insert(${randomResultName}, string.char(${randomByteName})) end end return table.concat(${randomResultName}) end `;

            // First apply variable renaming
            code = processVariableRenaming(code);

            // Then process string literals
            code = code.replace(/(['"])((?:\\.|(?!\1)[^\\])*)\1/g, function(match, quote, str) {
                const offset = Math.floor(Math.random() * 25) + 1;
                const encodedStr = caesarCipher(str, offset);
                return `${randomDecryptName}(${quote}${encodedStr}${quote}, ${offset})`;
            });

            return decodeFunction + code;
        }

        // Garbage Code Inserter functions
        const LOWERCASE_A = 97;
        const LOWERCASE_Z = 122;
        const MAX_RANDOM_NUMBER = 100;
        const MAX_LOOP_COUNT = 10;
        const VARIABLE_NAME_LENGTH = 6;

        function generateRandomVariableName() {
            let name = "";
            for (let i = 0; i < VARIABLE_NAME_LENGTH; i++) {
                name += String.fromCharCode(Math.floor(Math.random() * (LOWERCASE_Z - LOWERCASE_A + 1)) + LOWERCASE_A);
            }
            return name;
        }

        function generateRandomNumber(max = MAX_RANDOM_NUMBER) {
            return Math.floor(Math.random() * max) + 1;
        }

        const codeTypes = {
            variable: function() {
                return `local ${generateRandomVariableName()} = ${generateRandomNumber()}`;
            },
            while_loop: function() {
                return `while ${Math.random() > 0.5} do local _ = ${generateRandomNumber(100)} break end`;
            },
            for_loop: function() {
                return `for ${generateRandomVariableName()} = 1, ${generateRandomNumber(MAX_LOOP_COUNT)} do local _ = ${generateRandomNumber()} end`;
            },
            if_statement: function() {
                return `if ${Math.random() > 0.5} then local _ = ${generateRandomNumber()} end`;
            },
            function_def: function() {
                return `local function ${generateRandomVariableName()}(${generateRandomVariableName()}) local _ = ${generateRandomNumber()} end`;
            }
        };

        const codeTypeKeys = Object.keys(codeTypes);

        function generateRandomCode() {
            const randomKey = codeTypeKeys[Math.floor(Math.random() * codeTypeKeys.length)];
            return codeTypes[randomKey]();
        }

        function generateGarbage(blocks, sep = " ") {
            const garbageCode = [];
            for (let i = 0; i < blocks; i++) {
                const code = generateRandomCode();
                if (!code.includes("while true") && !code.match(/for \w+ = \d+, \d+ do local _ = \d+ end/)) {
                    garbageCode.push(code);
                }
            }
            return garbageCode.join(sep);
        }

        function processGarbageCode(code, garbageBlocks) {
            if (typeof code !== "string" || code.length === 0) {
                throw new Error("Input code must be a non-empty string");
            }
            if (typeof garbageBlocks !== "number") {
                throw new Error("garbage_blocks must be a number");
            }
            
            const prefixGarbage = generateGarbage(garbageBlocks, " ");
            const suffixGarbage = generateGarbage(garbageBlocks, " ");
            
            return prefixGarbage + " " + code + " " + suffixGarbage;
        }

        function addPadding(content) {
            // Use garbage code inserter for better padding
            const garbageBlocks = 50; // Number of garbage code blocks
            return processGarbageCode(content, garbageBlocks);
        }

        function obfuscateScript() {
            const input = document.getElementById('scriptInput').value.trim();
            const button = document.getElementById('obfuscateBtn');
            const status = document.getElementById('status');

            if (!input) {
                status.innerHTML = '<span class="error">Please enter a script to obfuscate!</span>';
                return;
            }

            button.disabled = true;
            button.textContent = 'Processing...';
            status.innerHTML = 'Obfuscating script...';

            setTimeout(() => {
                try {
                    let obfuscatedCode = processScript(input);
                    
                    // Add padding to reach approximately 1MB
                    const targetSize = 1024 * 1024; // 1MB
                    while (obfuscatedCode.length < targetSize) {
                        obfuscatedCode = addPadding(obfuscatedCode);
                        if (obfuscatedCode.length > targetSize * 1.5) break; // Safety check
                    }

                    // Create download
                    const blob = new Blob([obfuscatedCode], { type: 'text/plain' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    
                    const now = new Date();
                    const timestamp = now.toISOString().replace(/[:.]/g, '-').slice(0, -5);
                    
                    a.href = url;
                    a.download = `obfuscated_script_${timestamp}.lua`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);

                    const fileSizeKB = Math.round(obfuscatedCode.length / 1024);
                    status.innerHTML = `<span class="success">Script obfuscated successfully! File downloaded (${fileSizeKB} KB)</span>`;
                } catch (error) {
                    status.innerHTML = '<span class="error">Error obfuscating script. Please check your code.</span>';
                } finally {
                    button.disabled = false;
                    button.textContent = 'Obfuscate Script';
                }
            }, 500);
        }

        // Allow Enter key in textarea but not submit
        document.getElementById('scriptInput').addEventListener('keydown', function(e) {
            if (e.key === 'Enter' && e.ctrlKey) {
                obfuscateScript();
            }
        });
    </script>
</body>
</html>
