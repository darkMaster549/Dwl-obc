<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Roblox Script Obfuscator</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
            margin: 0;
            padding: 20px;
        }
        
        .container {
            max-width: 800px;
            margin: 0 auto;
            background-color: white;
            border: 2px solid #ccc;
            padding: 20px;
        }
        
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 20px;
        }
        
        .input-section {
            margin-bottom: 20px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #555;
        }
        
        textarea {
            width: 100%;
            height: 300px;
            padding: 10px;
            border: 2px solid #ddd;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            resize: vertical;
            box-sizing: border-box;
        }
        
        .button-section {
            text-align: center;
            margin: 20px 0;
        }
        
        button {
            background-color: #4CAF50;
            color: white;
            padding: 15px 30px;
            font-size: 16px;
            border: none;
            cursor: pointer;
            border-radius: 4px;
        }
        
        button:hover {
            background-color: #45a049;
        }
        
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        
        .status {
            text-align: center;
            margin: 10px 0;
            font-weight: bold;
        }
        
        .success {
            color: #4CAF50;
        }
        
        .error {
            color: #f44336;
        }
        
        .footer {
            text-align: center;
            margin-top: 20px;
            color: #666;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Roblox Script Obfuscator</h1>
        <p style="text-align: center; color: #666;">Put Your Whole Roblox Script for your Delta, KRNL, executors</p>
        
        <div class="input-section">
            <label for="scriptInput">Enter your Roblox script:</label>
            <textarea id="scriptInput" placeholder="-- Put your Roblox Lua script here
print('Hello World!')
game:GetService('Players').LocalPlayer.Character.Humanoid.WalkSpeed = 50"></textarea>
        </div>
        
        <div class="button-section">
            <button id="obfuscateBtn" onclick="obfuscateScript()">Obfuscate Script</button>
        </div>
        
        <div id="status" class="status"></div>
        
        <div class="footer">
            <p>This tool obfuscates Roblox Lua scripts using Caesar cipher encoding</p>
            <p>The obfuscated file will be automatically downloaded</p>
        </div>
    </div>

    <script>
        function generateRandomName(len = null) {
            len = len || Math.floor(Math.random() * 5) + 8;
            const charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
            let name = "";
            for (let i = 0; i < len; i++) {
                const index = Math.floor(Math.random() * charset.length);
                name += charset[index];
            }
            return name;
        }

        function isValidChar(byte) {
            return (byte >= 48 && byte <= 57) || (byte >= 65 && byte <= 90) || (byte >= 97 && byte <= 122);
        }

        function caesarCipher(data, offset) {
            let result = "";
            for (let i = 0; i < data.length; i++) {
                const byte = data.charCodeAt(i);
                if (isValidChar(byte)) {
                    let newByte;
                    if (byte >= 48 && byte <= 57) {
                        newByte = ((byte - 48 + offset) % 10) + 48;
                    } else if (byte >= 65 && byte <= 90) {
                        newByte = ((byte - 65 + offset) % 26) + 65;
                    } else if (byte >= 97 && byte <= 122) {
                        newByte = ((byte - 97 + offset) % 26) + 97;
                    }
                    result += String.fromCharCode(newByte);
                } else {
                    result += String.fromCharCode(byte);
                }
            }
            return result;
        }

        // Variable Renamer functions
        const varencNames = {};
        const luaFunctions = [
            "assert", "collectgarbage", "dofile", "loadfile", "loadstring",
            "ipairs", "pairs", "tonumber", "tostring", "type", "print",
            "_G", "_VERSION", "write", "sort",
            "math.abs", "math.acos", "math.asin", "math.atan", "math.atan2",
            "math.ceil", "math.cos", "math.cosh", "math.deg", "math.exp",
            "math.floor", "math.fmod", "math.frexp", "math.ldexp", "math.log",
            "math.log10", "math.max", "math.min", "math.modf", "math.pi",
            "math.pow", "math.rad", "math.random", "math.randomseed", "math.sin",
            "math.sinh", "math.sqrt", "math.tan", "math.tanh",
            "string.byte", "string.char", "string.dump", "string.find",
            "string.format", "string.gmatch", "string.gsub", "string.len",
            "string.lower", "string.match", "string.rep", "string.reverse",
            "string.sub", "string.upper",
            "table.concat", "table.insert", "table.remove", "table.sort",
            "table.pack", "table.unpack"
        ];

        const reservedWords = {
            "if": true, "then": true, "else": true, "elseif": true, "end": true,
            "for": true, "while": true, "do": true, "repeat": true, "until": true,
            "function": true, "local": true, "return": true, "break": true, "continue": true,
            "and": true, "or": true, "not": true, "in": true, "nil": true,
            "true": true, "false": true
        };

        function replaceUnquoted(input, target, replacement) {
            const placeholder = "!!!";
            let protectedInput = input.replace(/(['"])((?:\\.|(?!\1)[^\\])*)\1/g, function(match, quote, content) {
                content = content.replace(/\\"/g, '!@!').replace(/\\'/g, '@!@');
                content = content.replace(new RegExp(target, 'g'), placeholder);
                content = content.replace(/!@!/g, '\\"').replace(/@!@/g, "\\'");
                return quote + content + quote;
            });
            
            const regex = new RegExp('(\\b)' + target.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '(\\b)', 'g');
            let result = protectedInput.replace(regex, '$1' + replacement + '$2');
            result = result.replace(new RegExp(placeholder, 'g'), target);
            return result;
        }

        function obfuscateLocalVariables(code) {
            const localVarPattern = /local\s+([a-zA-Z_][a-zA-Z0-9_,\s]*)\s*=/g;
            const varMap = {};
            let obfuscatedCode = code;
            let match;

            while ((match = localVarPattern.exec(code)) !== null) {
                const localVars = match[1];
                const vars = localVars.match(/[a-zA-Z_][a-zA-Z0-9_]*/g);
                if (vars) {
                    for (const varName of vars) {
                        if (varName.length > 1 && !varencNames[varName] && !reservedWords[varName]) {
                            varMap[varName] = generateRandomName();
                        }
                    }
                }
            }

            for (const [originalVar, obfuscatedVar] of Object.entries(varMap)) {
                obfuscatedCode = replaceUnquoted(obfuscatedCode, originalVar, obfuscatedVar);
            }

            return { obfuscatedCode, varMap };
        }

        function obfuscateFunctions(code) {
            const funcMap = {};
            const argMap = {};
            let obfuscatedCode = code;

            // Match function definitions
            const funcPattern = /function\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*\(([a-zA-Z0-9_,\s]*)\)/g;
            let match;

            while ((match = funcPattern.exec(code)) !== null) {
                const funcName = match[1];
                const args = match[2];

                if (!reservedWords[funcName] && !funcMap[funcName]) {
                    funcMap[funcName] = generateRandomName();
                }

                if (args) {
                    const argList = args.match(/[a-zA-Z_][a-zA-Z0-9_]*/g);
                    if (argList) {
                        for (const arg of argList) {
                            if (!reservedWords[arg] && !argMap[arg]) {
                                argMap[arg] = generateRandomName();
                            }
                        }
                    }
                }
            }

            // Replace function names
            obfuscatedCode = obfuscatedCode.replace(/function\s+([a-zA-Z_][a-zA-Z0-9_]*)/g, function(match, funcName) {
                return "function " + (funcMap[funcName] || funcName);
            });

            // Replace function calls
            for (const [originalFunc, obfuscatedFunc] of Object.entries(funcMap)) {
                const regex = new RegExp(originalFunc.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '\\(', 'g');
                obfuscatedCode = obfuscatedCode.replace(regex, obfuscatedFunc + "(");
            }

            // Replace arguments
            for (const [originalArg, obfuscatedArg] of Object.entries(argMap)) {
                obfuscatedCode = replaceUnquoted(obfuscatedCode, originalArg, obfuscatedArg);
            }

            return obfuscatedCode;
        }

        function processVariableRenaming(code) {
            const renamedVars = [];
            const assignmentLines = [];
            
            const { obfuscatedCode: varObfuscatedCode } = obfuscateLocalVariables(code);
            let finalCode = obfuscateFunctions(varObfuscatedCode);

            // Handle built-in functions - be more careful with replacements
            for (const functionName of luaFunctions) {
                if (code.includes(functionName + "(")) {
                    if (!varencNames[functionName]) {
                        const newName = generateRandomName();
                        varencNames[functionName] = newName;
                        renamedVars.push(newName);
                        assignmentLines.push(newName + "=" + functionName);
                    }
                    // Only replace function calls, not partial matches
                    const regex = new RegExp(functionName.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '\\(', 'g');
                    finalCode = finalCode.replace(regex, varencNames[functionName] + "(");
                }
            }

            const localDeclaration = renamedVars.length > 0 ? "local " + renamedVars.join(",") : "";
            const assignments = assignmentLines.length > 0 ? " " + assignmentLines.join(" ") : "";
            
            return localDeclaration + assignments + " " + finalCode;
        }

        // Compressor functions
        const LUA_KEYWORDS = [
            "and", "break", "do", "else", "elseif", "end", "false", "for", "function",
            "goto", "if", "in", "local", "nil", "not", "or", "repeat", "return",
            "then", "true", "until", "while"
        ];

        const KW_PLACEHOLDER_PRE = "@@KW_";
        const KW_PLACEHOLDER_POST = "_KW@@";
        const STR_PLACEHOLDER_PRE = "@@S_";
        const STR_PLACEHOLDER_POST = "_S@@";

        function processCompressor(code) {
            if (typeof code !== "string") {
                throw new Error("Input code must be a string.");
            }
            if (code.length < 10 || /^[\s\d\p{P}]*$/u.test(code)) {
                return code.trim() || "";
            }

            let strings = {};
            let stringCount = 0;
            let keywordsMap = {};

            function preserveStrings(c) {
                // Long strings
                c = c.replace(/\[(=*)\[([\s\S]*?)\]\1\]/g, function(match, equals, str) {
                    stringCount++;
                    const key = STR_PLACEHOLDER_PRE + stringCount + STR_PLACEHOLDER_POST;
                    strings[key] = "[" + equals + "[" + str + "]" + equals + "]";
                    return key;
                });
                
                // Double quoted strings
                c = c.replace(/"((?:\\.|[^"\\])*)"/g, function(match, str) {
                    if (!str.includes("\\") && str.includes(STR_PLACEHOLDER_PRE)) {
                        return '"' + str + '"';
                    }
                    stringCount++;
                    const key = STR_PLACEHOLDER_PRE + stringCount + STR_PLACEHOLDER_POST;
                    strings[key] = '"' + str + '"';
                    return key;
                });
                
                // Single quoted strings
                c = c.replace(/'((?:\\.|[^'\\])*)'/g, function(match, str) {
                    if (!str.includes("\\") && str.includes(STR_PLACEHOLDER_PRE)) {
                        return "'" + str + "'";
                    }
                    stringCount++;
                    const key = STR_PLACEHOLDER_PRE + stringCount + STR_PLACEHOLDER_POST;
                    strings[key] = match;
                    return key;
                });
                
                return c;
            }

            function preserveKeywords(c) {
                for (const keyword of LUA_KEYWORDS) {
                    const placeholder = KW_PLACEHOLDER_PRE + keyword + KW_PLACEHOLDER_POST;
                    keywordsMap[placeholder] = keyword;
                    
                    const regex1 = new RegExp("([^\\w_])(" + keyword + ")([^\\w_])", "g");
                    const regex2 = new RegExp("^(" + keyword + ")([^\\w_])");
                    const regex3 = new RegExp("([^\\w_])(" + keyword + ")$");
                    const regex4 = new RegExp("^(" + keyword + ")$");
                    
                    c = c.replace(regex1, "$1" + placeholder + "$3");
                    c = c.replace(regex2, placeholder + "$2");
                    c = c.replace(regex3, "$1" + placeholder);
                    c = c.replace(regex4, placeholder);
                }
                return c;
            }

            function restoreKeywords(c) {
                for (const [placeholder, keyword] of Object.entries(keywordsMap)) {
                    c = c.replace(new RegExp(placeholder.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g'), keyword);
                }
                return c;
            }

            function restoreStrings(c) {
                for (let i = stringCount; i >= 1; i--) {
                    const key = STR_PLACEHOLDER_PRE + i + STR_PLACEHOLDER_POST;
                    if (strings[key]) {
                        c = c.replace(new RegExp(key.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g'), strings[key]);
                    }
                }
                return c;
            }

            code = preserveStrings(code);
            code = preserveKeywords(code);

            // Remove comments
            code = code.replace(/--\[\[[\s\S]*?\]\]/g, "");
            code = code.replace(/--[^\n]*/g, "");

            // Compress whitespace
            code = code.replace(/[\n\r]+/g, " ");
            code = code.replace(/\s+/g, " ");

            // Compress operators
            code = code.replace(/\s*\.\.\s*/g, "..");
            code = code.replace(/\s*([+\-*/%\\^#<>~=,;:(){}[\]])\s*/g, "$1");
            code = code.replace(/\s*\.\s*/g, ".");
            code = code.replace(/\.\./g, "..");

            code = code.trim();

            code = restoreKeywords(code);
            code = restoreStrings(code);

            return code;
        }

        // Opaque Predicate Injector functions
        function generatePredicates() {
            const predicates = [
                function() {
                    const n = Math.floor(Math.random() * 91) + 10;
                    return `if (${n} % 1 == 0 and ${n} >= ${n}) then `;
                },
                function() {
                    const x = Math.floor(Math.random() * 10) + 1;
                    return `if (${x} % ${x} == 0) then `;
                },
                function() {
                    const angle = Math.floor(Math.random() * 361);
                    return `if (math.sin(${angle})^2 + math.cos(${angle})^2 >= 0.99999) then `;
                },
                function() {
                    const hex = Math.floor(Math.random() * 9000) + 1000;
                    return `if (select(2, pcall(function() return tonumber('${hex.toString(16)}', 16) end)) ~= nil) then `;
                },
                function() {
                    const size = Math.floor(Math.random() * 4) + 2;
                    const array = "1,".repeat(size - 1) + "1";
                    return `if (#{${array}} == ${size}) then `;
                },
                function() {
                    const a = Math.floor(Math.random() * 10) + 1;
                    const b = Math.floor(Math.random() * 10) + 11;
                    return `if ((${a} < ${b}) == not (${a} >= ${b})) then `;
                }
            ];
            return predicates[Math.floor(Math.random() * predicates.length)]();
        }

        function isInjectSafe(statement) {
            if (/^\s*[{}]\s*$/.test(statement) ||
                /^\s*$/.test(statement) ||
                !statement.includes(";")) {
                return false;
            }

            const unsafePatterns = [
                /^\s*for\s+/,
                /^\s*while\s+/,
                /^\s*if\s+/,
                /^\s*repeat\s+/,
                /^\s*until\s+/,
                /^\s*function\s+/,
                /^\s*local\s+function/,
                /^\s*do\s+/
            ];

            for (const pattern of unsafePatterns) {
                if (pattern.test(statement)) {
                    return false;
                }
            }

            if (/^\s*if\s+.+\s+then\s+.+\s+end\s*;?$/.test(statement)) {
                return false;
            }

            return true;
        }

        function injectPredicates(block) {
            if (/\s*end\s*;?$/.test(block) || /^\s*return/.test(block)) {
                return block;
            } else {
                const predicate = generatePredicates();
                return predicate + block + " end ";
            }
        }

        function processOpaquePredicates(code) {
            if (typeof code !== "string") {
                throw new Error("Input must be a string");
            }

            try {
                let result = code.replace(/([ \t]*)([^\n;]*;)/g, function(match, ws, statement) {
                    if (isInjectSafe(statement)) {
                        return ws + injectPredicates(statement);
                    } else {
                        return ws + statement;
                    }
                });

                result = result.replace(/([ \t]*)(return\s+[^\n;]+;)/g, function(match, ws, returnStmt) {
                    return ws + returnStmt;
                });

                return result;
            } catch (error) {
                throw new Error("Failed to process code: " + error.message);
            }
        }

        // Wrapper function
        function processWrapper(code) {
            return `return (function(...) ${code} end)(...)`;
        }

        function processScript(code) {
            const randomDecryptName = generateRandomName();
            const randomIsValidCharName = generateRandomName();
            const randomResultName = generateRandomName();
            const randomCodeName = generateRandomName();
            const randomOffsetName = generateRandomName();
            const randomByteName = generateRandomName();
            const randomNewByteName = generateRandomName();

            const decodeFunction = `local function ${randomIsValidCharName}(${randomByteName}) return (${randomByteName} >= 48 and ${randomByteName} <= 57) or (${randomByteName} >= 65 and ${randomByteName} <= 90) or (${randomByteName} >= 97 and ${randomByteName} <= 122) end local function ${randomDecryptName}(${randomCodeName}, ${randomOffsetName}) local ${randomResultName} = {} for i = 1, #${randomCodeName} do local ${randomByteName} = ${randomCodeName}:byte(i) if ${randomIsValidCharName}(${randomByteName}) then local ${randomNewByteName} if ${randomByteName} >= 48 and ${randomByteName} <= 57 then ${randomNewByteName} = ((${randomByteName} - 48 - ${randomOffsetName} + 10) % 10) + 48 elseif ${randomByteName} >= 65 and ${randomByteName} <= 90 then ${randomNewByteName} = ((${randomByteName} - 65 - ${randomOffsetName} + 26) % 26) + 65 elseif ${randomByteName} >= 97 and ${randomByteName} <= 122 then ${randomNewByteName} = ((${randomByteName} - 97 - ${randomOffsetName} + 26) % 26) + 97 end table.insert(${randomResultName}, string.char(${randomNewByteName})) else table.insert(${randomResultName}, string.char(${randomByteName})) end end return table.concat(${randomResultName}) end `;

            // First apply compressor to minify the code
            code = processCompressor(code);
            
            // Then apply opaque predicates
            code = processOpaquePredicates(code);
            
            // Then apply control flow obfuscation
            code = processControlFlow(code);
            
            // Then apply variable renaming
            code = processVariableRenaming(code);

            // Then process string literals
            code = code.replace(/(['"])((?:\\.|(?!\1)[^\\])*)\1/g, function(match, quote, str) {
                const offset = Math.floor(Math.random() * 25) + 1;
                const encodedStr = caesarCipher(str, offset);
                return `${randomDecryptName}(${quote}${encodedStr}${quote}, ${offset})`;
            });

            // Finally wrap the entire code
            const wrappedCode = processWrapper(decodeFunction + code);

            return wrappedCode;
        }

        // Garbage Code Inserter functions
        const LOWERCASE_A = 97;
        const LOWERCASE_Z = 122;
        const MAX_RANDOM_NUMBER = 100;
        const MAX_LOOP_COUNT = 10;
        const VARIABLE_NAME_LENGTH = 6;

        function generateRandomVariableName() {
            let name = "";
            for (let i = 0; i < VARIABLE_NAME_LENGTH; i++) {
                name += String.fromCharCode(Math.floor(Math.random() * (LOWERCASE_Z - LOWERCASE_A + 1)) + LOWERCASE_A);
            }
            return name;
        }

        function generateRandomNumber(max = MAX_RANDOM_NUMBER) {
            return Math.floor(Math.random() * max) + 1;
        }

        const codeTypes = {
            variable: function() {
                return `local ${generateRandomVariableName()} = ${generateRandomNumber()}`;
            },
            while_loop: function() {
                return `while ${Math.random() > 0.5} do local _ = ${generateRandomNumber(100)} break end`;
            },
            for_loop: function() {
                return `for ${generateRandomVariableName()} = 1, ${generateRandomNumber(MAX_LOOP_COUNT)} do local _ = ${generateRandomNumber()} end`;
            },
            if_statement: function() {
                return `if ${Math.random() > 0.5} then local _ = ${generateRandomNumber()} end`;
            },
            function_def: function() {
                return `local function ${generateRandomVariableName()}(${generateRandomVariableName()}) local _ = ${generateRandomNumber()} end`;
            }
        };

        const codeTypeKeys = Object.keys(codeTypes);

        function generateRandomCode() {
            const randomKey = codeTypeKeys[Math.floor(Math.random() * codeTypeKeys.length)];
            return codeTypes[randomKey]();
        }

        function generateGarbage(blocks, sep = " ") {
            const garbageCode = [];
            for (let i = 0; i < blocks; i++) {
                const code = generateRandomCode();
                if (!code.includes("while true") && !code.match(/for \w+ = \d+, \d+ do local _ = \d+ end/)) {
                    garbageCode.push(code);
                }
            }
            return garbageCode.join(sep);
        }

        function processGarbageCode(code, garbageBlocks) {
            if (typeof code !== "string" || code.length === 0) {
                throw new Error("Input code must be a non-empty string");
            }
            if (typeof garbageBlocks !== "number") {
                throw new Error("garbage_blocks must be a number");
            }
            
            const prefixGarbage = generateGarbage(garbageBlocks, " ");
            const suffixGarbage = generateGarbage(garbageBlocks, " ");
            
            return prefixGarbage + " " + code + " " + suffixGarbage;
        }

        // Control Flow Obfuscator functions
        function controlFlowObfuscate(code, n = null, a = null, depth = 0, depthValues = []) {
            n = n || Math.floor(Math.random() * 7000);
            a = n;
            depthValues.push({n, a});

            const operators = [">", "<", "=="];
            const whileOperator = operators[Math.floor(Math.random() * 3)];
            
            const step = Math.floor(Math.random() * 990) + 10;
            const maxIterations = 3;
            
            if (whileOperator === "<") {
                a = n + (step * maxIterations);
            } else if (whileOperator === ">") {
                a = n - (step * maxIterations);
                if (a < 0) a = 0;
            } else if (whileOperator === "==") {
                a = n;
            }

            const threshold = (n + step);
            
            let src = depth === 0 ? `local thing = ${n} local thing2 = ${a} local counter = 0 local threshold = ${threshold} ` : "";
            
            src += `while thing ${whileOperator} thing2 and counter < ${maxIterations} do `;
            src += `thing = thing + ${step} `;
            src += `counter = counter + 1 `;
            src += `if thing < threshold then `;

            const spoofLines = [
                `local temp = ${Math.floor(Math.random() * 100)} temp = temp * 2`,
                `local str = 'dummy' str = str .. str`,
                `local x = ${Math.floor(Math.random() * 50)} x = x - ${Math.floor(Math.random() * 10)}`,
                `local tbl = {1, 2, 3} table.sort(tbl, function(a, b) return a > b end)`
            ];
            const spoof = spoofLines[Math.floor(Math.random() * spoofLines.length)];

            if (Array.isArray(code) && code.length === 1) {
                src += `${spoof} `;
                src += `else ${code[0]} break `;
            } else {
                src += `${spoof} `;
                src += `else ${code} break `;
            }

            src += `end end `;

            if (Math.random() > 0.5) {
                src += `local dummy = 1 dummy = dummy + ${Math.floor(Math.random() * 10)} `;
            }

            return src;
        }

        function processControlFlow(code) {
            return controlFlowObfuscate(code);
        }

        function addPadding(content) {
            // Much smaller padding for 50KB target
            const garbageBlocks = 5; // Very small amount
            return processGarbageCode(content, garbageBlocks);
        }

        function obfuscateScript() {
            const input = document.getElementById('scriptInput').value.trim();
            const button = document.getElementById('obfuscateBtn');
            const status = document.getElementById('status');

            if (!input) {
                status.innerHTML = '<span class="error">Please enter a script to obfuscate!</span>';
                return;
            }

            button.disabled = true;
            button.textContent = 'Processing...';
            status.innerHTML = 'Obfuscating script...';

            setTimeout(() => {
                try {
                    let obfuscatedCode = processScript(input);
                    
                    // Add padding to reach approximately 50KB
                    const targetSize = 50 * 1024; // 50KB
                    while (obfuscatedCode.length < targetSize) {
                        obfuscatedCode = addPadding(obfuscatedCode);
                        if (obfuscatedCode.length > targetSize * 1.5) break; // Safety check
                    }

                    // Create download
                    const blob = new Blob([obfuscatedCode], { type: 'text/plain' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    
                    const now = new Date();
                    const timestamp = now.toISOString().replace(/[:.]/g, '-').slice(0, -5);
                    
                    a.href = url;
                    a.download = `obfuscated_script_${timestamp}.lua`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);

                    const fileSizeKB = Math.round(obfuscatedCode.length / 1024);
                    status.innerHTML = `<span class="success">Script obfuscated successfully! File downloaded (${fileSizeKB} KB)</span>`;
                } catch (error) {
                    status.innerHTML = '<span class="error">Error obfuscating script. Please check your code.</span>';
                } finally {
                    button.disabled = false;
                    button.textContent = 'Obfuscate Script';
                }
            }, 500);
        }

        // Allow Enter key in textarea but not submit
        document.getElementById('scriptInput').addEventListener('keydown', function(e) {
            if (e.key === 'Enter' && e.ctrlKey) {
                obfuscateScript();
            }
        });
    </script>
</body>
</html>
